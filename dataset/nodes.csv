id,name
0,root
1,codegraph
2,codegraph/wehr.py
3,codegraph/utils.py
4,codegraph/main.py
5,tests
6,tests/test_data
7,tests/test_data/vizualyzer.py
8,tests/test_codegraph.py
9,codegraph/core.py
10,codegraph/vizualyzer.py
11,tests/test_utils.py
12,codegraph/parser.py
13,codegraph/awgr
14,codegraph/awgr/eagers.py
15,# location: codegraph/awgr/eagers.py\ndef cfa():\n    return "awgga"
16,# location: codegraph/core.py\ndef read_file_content(path: Text) -> Text:\n    with open(path, "r+") as file_read:\n        return file_read.read()
17,# location: codegraph/core.py\ndef parse_code_file(path: Text) -> List:\n    """read module source and parse to get objects array"""\n    source = read_file_content(path)\n    parsed_module = create_objects_array(source=source, fname=os.path.basename(path))\n    return parsed_module
18,# location: codegraph/core.py\ndef get_code_objects(paths_list: List) -> Dict:\n    """\n        get all code files data for paths list\n    :param paths_list: list with paths to code files to parse\n    :return:\n    """\n    all_data = {}\n    for path in paths_list:\n        content = parse_code_file(path)\n        all_data[path] = content\n    return all_data
19,# location: codegraph/core.py\nCodeGraph.__init__\nCodeGraph.get_lines_numbers\nCodeGraph.usage_graph\nCodeGraph.get_dependencies
20,# location: codegraph/core.py\n    def __init__(self, args: Namespace):\n        self.paths_list = get_python_paths_list(args.paths)\n        # get py modules list data\n        self.modules_data = get_code_objects(self.paths_list)
21,# location: codegraph/core.py\n    def get_lines_numbers(self):\n        """\n           return data with entities names and start and end line\n        :return: Example: {'/Users/user/package/module_name.py':\n                {'function': (1, 2), 'function_with_constant_return_int': (5, 6),\n                'function_with_constant_return_float': (9, 10),\n                'function_with_statement_return': (13, 14)..}}\n\n                first number in tuple - start line, second - last line\n        """\n        data = {}\n        for module in self.modules_data:\n            data[module] = {}\n            for func in self.modules_data[module]:\n                data[module][func.name] = (func.lineno, func.endno)\n        return data
22,# location: codegraph/core.py\n    def usage_graph(self) -> Dict:\n        """\n            module name: function\n        :return:\n        """\n        entities_lines, imports, modules_names_map = get_imports_and_entities_lines(\n            self.modules_data\n        )\n        entities_usage_in_modules = collect_entities_usage_in_modules(\n            self.modules_data, imports, modules_names_map\n        )\n        # create edges\n        dependencies = defaultdict(dict)\n        for module in entities_usage_in_modules:\n            dependencies[module] = defaultdict(list)\n            for method_that_used in entities_usage_in_modules[module]:\n                method_usage_lines = entities_usage_in_modules[module][method_that_used]\n                for method_usage_line in method_usage_lines:\n                    for entity in entities_lines[module]:\n                        if entity[0] <= method_usage_line <= entity[1]:\n                            dependencies[module][entities_lines[module][entity]].append(\n                                method_that_used\n                            )\n                            break\n                    else:\n                        # mean in global of module\n                        dependencies[module]["_"].append(method_that_used)\n        dependencies = populate_free_nodes(self.modules_data, dependencies)\n        return dependencies
23,# location: codegraph/core.py\n    def get_dependencies(self, file_path: str, distance: int) -> Dict[str, Set[str]]:\n        """\n        Get dependencies that are 'distance' nodes away from the given file.\n\n        :param file_path: Path of the file to start from\n        :param distance: Number of edges to traverse\n        :return: Dictionary with distances as keys and sets of dependent files as values\n        """\n        dependencies = {i: set() for i in range(1, distance + 1)}\n        graph = self.usage_graph()\n\n        if file_path not in graph:\n            return dependencies\n\n        queue = deque([(file_path, 0)])\n        visited = set()\n\n        while queue:\n            current_file, current_distance = queue.popleft()\n\n            if current_distance >= distance:\n                continue\n\n            if current_file not in visited:\n                visited.add(current_file)\n\n                for entity, used_entities in graph[current_file].items():\n                    for used_entity in used_entities:\n                        if "." in used_entity:\n                            dependent_file = used_entity.split(".")[0] + ".py"\n                            if dependent_file != current_file:\n                                dependencies[current_distance + 1].add(dependent_file)\n                                queue.append((dependent_file, current_distance + 1))\n\n        return dependencies
24,# location: codegraph/core.py\ndef get_module_name(code_path: Text) -> Text:\n    module_name = os.path.basename(code_path).replace(".py", "")\n    return module_name
25,# location: codegraph/core.py\ndef module_name_in_imports(imports: List, module_name: Text) -> bool:\n    for import_ in imports:\n        if module_name in import_:\n            return True\n    return False
26,# location: codegraph/core.py\ndef get_imports_and_entities_lines(  # noqa: C901\n    code_objects: Dict,\n) -> Tuple[Dict, Dict, Dict]:\n    # todo: need to do optimization\n    """\n    joined together to avoid iteration several time\n    imports - list of modules in code_objects Dict that used in current module\n    """\n    entities_lines = defaultdict(dict)\n    imports = defaultdict(list)\n    modules_ = code_objects.keys()\n    names_map = {}\n    for path in code_objects:\n        _base_folder = os.path.basename(os.path.dirname(path))\n        names_map[get_module_name(path)] = path\n        # for each module in list\n        if code_objects[path] and isinstance(code_objects[path][-1], Import):\n            # extract imports if exist\n            for import_ in code_objects[path].pop(-1).modules:\n                pathed_import = import_\n                alias = None\n                if " as " in pathed_import:\n                    pathed_import, alias = pathed_import.split(" as ")\n                if _base_folder + "." in pathed_import:\n                    pathed_import = pathed_import.replace(".", "/").split(\n                        _base_folder + "/"\n                    )[1]\n                if "/" in pathed_import:\n                    pathed_import = pathed_import.split("/")[0]\n                for module_ in modules_:\n                    if pathed_import and pathed_import in module_:\n                        if alias:\n                            aliases[pathed_import] = alias\n                        imports[path].append(pathed_import)\n        for entity in code_objects[path]:\n            # create a dict with lines of start and end for each entity in module\n            entities_lines[path][(entity.lineno, entity.endno)] = entity.name\n    return entities_lines, imports, names_map
27,# location: codegraph/core.py\ndef search_entities_from_list_in_code(\n    entities_list: List, module_name: Text, line: Text\n) -> Text:\n    for entity in entities_list:\n        if search_entity_usage(module_name, entity.name, line):\n            yield entity
28,# location: codegraph/core.py\ndef search_entities_from_module_in_code(\n    _module: Text, _path: Text, code_objects: Dict, code: List, current: bool = False\n) -> Dict:\n    found_entities = defaultdict(list)\n    for num, line in enumerate(code):\n        if (\n            not line.startswith("#")\n            and not line.startswith('"')\n            and not line.startswith("'")\n        ):\n            entities_in_line = [\n                x\n                for x in search_entities_from_list_in_code(\n                    code_objects[_path], _module, line\n                )\n            ]\n            for entity in entities_in_line:\n                prefix = f"{_module}." if not current else ""\n                found_entities[f"{prefix}{entity.name}"].append(num + 1)\n    return found_entities
29,# location: codegraph/core.py\ndef collect_entities_usage_in_modules(\n    code_objects: Dict, imports: Dict, modules_names_map: Dict\n) -> Dict:\n    entities_usage_in_modules = defaultdict(dict)\n    for path in code_objects:\n        entities_usage_in_modules[path] = defaultdict(list)\n        # print(f"Start to work with module: {path}")\n        # print(f"Imports in module: {imports}")\n        module_content = read_file_content(path)\n        # to reduce count of iteration, we not need lines with functions and classes defenitions\n        module_content = (\n            module_content.replace("async ", "# async ")\n            .replace("def ", "# def ")\n            .replace("class ", "# class ")\n        )\n        # split by line\n        code = module_content.split("\n")\n        for _module in imports[path]:\n            # search entities from other modules\n            _path = modules_names_map[_module]\n            entities_usage_in_modules[path].update(\n                search_entities_from_module_in_code(_module, _path, code_objects, code)\n            )\n        # search entities from current module\n        entities_usage_in_modules[path].update(\n            search_entities_from_module_in_code(\n                get_module_name(path), path, code_objects, code, current=True\n            )\n        )\n    return entities_usage_in_modules
30,# location: codegraph/core.py\ndef populate_free_nodes(code_objects: Dict, dependencies: Dict) -> Dict:\n    for path in code_objects:\n        for entity in code_objects[path]:\n            if entity.name not in dependencies[path]:\n                dependencies[path][entity.name] = []\n    return dependencies
31,# location: codegraph/core.py\ndef search_entity_usage(module_name: Text, name: Text, line: Text) -> bool:\n    """check exist method or entity usage in line or not"""\n    method_call = name + "("\n    dot_access = name + "."\n    if (\n        method_call in line\n        or " " + dot_access in line\n        or f"{module_name}." + method_call in line\n        or f"{module_name}." + dot_access in line\n    ):\n        return True\n    elif module_name in aliases:\n        if aliases[module_name] + "." + method_call in line:\n            return True\n    return False
32,# location: codegraph/main.py\ndef cli(paths, object_only, file_path, distance):\n    """\n    Tool that creates a graph of code to show dependencies between code entities (methods, classes, etc.).\n    CodeGraph does not execute code, it is based only on lex and syntax parsing.\n\n    PATHS: Provide path(s) to code base\n    """\n    if not paths:\n        click.echo(\n            "Error: No paths provided. Please specify at least one path to the code base.",\n            err=True,\n        )\n        sys.exit(1)\n\n    args = {\n        "paths": paths,\n        "object_only": object_only,\n        "file_path": file_path,\n        "distance": distance,\n    }\n    main(args)
33,# location: codegraph/main.py\ndef main(args):\n    code_graph = core.CodeGraph(args)\n    usage_graph = code_graph.usage_graph()\n\n    if args.get("file_path") and args.get("distance"):\n        dependencies = code_graph.get_dependencies(args["file_path"], args["distance"])\n        print(f"Dependencies for {args['file_path']}:")\n        for distance, files in dependencies.items():\n            print(f"  Distance {distance}: {', '.join(files)}")\n    else:\n        pprint.pprint(usage_graph)\n        if not args["object_only"]:\n            import codegraph.vizualyzer as vz\n\n            vz.draw_graph(usage_graph)
34,# location: codegraph/parser.py\n_Object.__init__\n_Object._addchild\n_Object.__repr__\n_Object.__str__
35,# location: codegraph/parser.py\n    def __init__(self, name: Text, file: Text, lineno: int, parent: object):\n        self.name = name\n        self.file = file\n        self.lineno = lineno\n        self.parent = parent if parent else object\n        self.children = {}\n        self.endno = None
36,# location: codegraph/parser.py\n    def _addchild(self, name, obj):\n        self.children[name] = obj\n        obj.main = self
37,# location: codegraph/parser.py\n    def __repr__(self):\n        return f"{self.name} <{self.__class__.__name__}: Parent {self.parent}>"
38,# location: codegraph/parser.py\n    def __str__(self):\n        return f"{self.name} <{self.__class__.__name__}>"
39,# location: codegraph/parser.py\nImport.__init__\nImport.add
40,# location: codegraph/parser.py\n    def __init__(self, modules: List):\n        self.modules = set()\n        for module in modules:\n            self.modules.add(module)
41,# location: codegraph/parser.py\n    def add(self, module):\n        self.modules.add(module)
42,# location: codegraph/parser.py\nFunction.__init__
43,# location: codegraph/parser.py\n    def __init__(self, name, file, lineno, parent=None):\n        _Object.__init__(self, name, file, lineno, parent)
44,# location: codegraph/parser.py\nAsyncFunction.__init__
45,# location: codegraph/parser.py\n    def __init__(self, name, file, lineno, parent=None):\n        _Object.__init__(self, name, file, lineno, parent)
46,# location: codegraph/parser.py\nClass.__init__\nClass._addmethod\nClass._add_async_method
47,# location: codegraph/parser.py\n    def __init__(self, name, super, file, lineno, parent=None):\n        _Object.__init__(self, name, file, lineno, parent)\n        self.super = [] if super is None else super\n        self.methods = {}\n        self.async_methods = {}
48,# location: codegraph/parser.py\n    def _addmethod(self, name, newfunc):\n        self.methods[name] = newfunc
49,# location: codegraph/parser.py\n    def _add_async_method(self, name, newfunc):\n        self.async_methods[name] = newfunc
50,# location: codegraph/parser.py\ndef _nest_function(ob, func_name, lineno, async_f=False):\n    "Return a Function after nesting within ob."\n    newfunc = Function(func_name, ob.file, lineno, ob)\n    ob._addchild(func_name, newfunc)\n    if isinstance(ob, Class):\n        if not async_f:\n            ob._addmethod(func_name, newfunc)\n        else:\n            ob._add_async_method(func_name, newfunc)\n    return newfunc
51,# location: codegraph/parser.py\ndef _nest_class(ob, class_name, lineno, super=None):\n    "Return a Class after nesting within ob."\n    newclass = Class(class_name, super, ob.file, lineno, ob)\n    ob._addchild(class_name, newclass)\n    return newclass
52,# location: codegraph/parser.py\ndef create_objects_array(fname, source):  # noqa: C901\n    # todo: need to do optimization\n    """Return an object list for a particular module."""\n    tree = []\n    f = io.StringIO(source)\n\n    stack = []\n\n    g = tokenize.generate_tokens(f.readline)\n\n    try:\n        new_lines = 0\n        imports = None\n        cur_func = None\n        for tokentype, token, start, _end, _line in g:\n            if tokentype == DEDENT:\n                lineno, thisindent = start\n                # Close previous nested classes and defs.\n                while stack and stack[-1][1] >= thisindent:\n                    if isinstance(stack[-1][0], _Object):\n                        if getattr(stack[-1][0], "main", None):\n                            stack[-1][0].endno = lineno - 1 - new_lines\n                        else:\n                            stack[-1][0].endno = lineno - 1 - new_lines\n                    del stack[-1]\n                else:\n                    if tree:\n                        tree[-1].endno = lineno - 1 - new_lines\n                new_lines = 0\n            elif tokentype == NL:\n                new_lines += 1\n\n            elif token == "import":\n                modules = [_line.replace("\n", "").split("import ")[1]]\n                if not imports:\n                    imports = Import(modules)\n                else:\n                    for module in modules:\n                        imports.add(module)\n            elif token == "from":\n                modules = [\n                    _line.replace("\n", "").split("from ")[1].replace(" import ", ".")\n                ]\n                if not imports:\n                    imports = Import(modules)\n                else:\n                    for module in modules:\n                        imports.add(module)\n            elif token == "async":\n                new_lines = 0\n                lineno, thisindent = start\n                # Close previous nested classes and defs.\n                while stack and stack[-1][1] >= thisindent:\n                    del stack[-1]\n                # next will be def\n                _, _, _ = next(g)[0:3]\n                # we need method name\n                tokentype, func_name, start = next(g)[0:3]\n                if tokentype != NAME:\n                    continue  # Skip def with syntax error.\n                cur_func = None\n                if stack:\n                    cur_obj = stack[-1][0]\n                    cur_func = _nest_function(cur_obj, func_name, lineno, async_f=True)\n                    cur_obj.endno = lineno - new_lines\n                else:\n                    tree.append(AsyncFunction(func_name, fname, lineno))\n                stack.append((cur_func, thisindent))\n            elif token == "def":\n                new_lines = 0\n                lineno, thisindent = start\n                # Close previous nested classes and defs.\n                while stack and stack[-1][1] >= thisindent:\n                    del stack[-1]\n                tokentype, func_name, start = next(g)[0:3]\n                if tokentype != NAME:\n                    continue  # Skip def with syntax error.\n                if stack:\n                    cur_obj = stack[-1][0]\n                    cur_func = _nest_function(cur_obj, func_name, lineno)\n                    cur_obj.endno = lineno - new_lines\n                else:\n                    cur_func = Function(func_name, fname, lineno)\n                    tree.append(cur_func)\n                if cur_func:\n                    stack.append((cur_func, thisindent))\n            elif token == "class":\n                new_lines = 0\n                lineno, thisindent = start\n                # Close previous nested classes and defs.\n                while stack and stack[-1][1] >= thisindent:\n                    del stack[-1]\n                tokentype, class_name, start = next(g)[0:3]\n\n                if tokentype != NAME:\n                    continue\n                inherit = None\n\n                if stack:\n                    cur_obj = stack[-1][0]\n                    cur_class = _nest_class(cur_obj, class_name, lineno, inherit)\n                    cur_obj.endno = lineno - new_lines\n                else:\n                    cur_class = Class(class_name, inherit, fname, lineno)\n                    tree.append(cur_class)\n                stack.append((cur_class, thisindent))\n\n    except StopIteration:\n        pass\n\n    f.close()\n    if imports:\n        tree.append(imports)\n    return tree
53,# location: codegraph/utils.py\ndef get_python_paths_list(paths: Union[str, List]) -> List[str]:\n    """\n        return list of paths to python files, that found in provided path\n    :param paths: paths to folder or python file that need to tests\n    :return:\n    """\n    if isinstance(paths, str):\n        paths = [paths]\n    if len(paths) == 1 and paths[0].endswith(".py"):\n        # mean provided path to one python module\n        path = Path(paths[0]).absolute()\n        if not path.exists():\n            raise ValueError(f"Path {path.as_posix()} does not exists")\n        return [path.as_posix()]\n\n    paths_list = []\n    for path in paths:\n        path = Path(path).absolute()\n        if not path.exists():\n            raise ValueError(f"Path {path.as_posix()} does not exist")\n        paths_list += [\n            Path(p).as_posix()\n            for p in glob.glob(str(path / "**" / "*.py"), recursive=True)\n            if not p.endswith("__init__.py")\n        ]\n    return paths_list
54,# location: codegraph/vizualyzer.py\ndef qwrgegwer():\n    agaerg()
55,# location: codegraph/vizualyzer.py\ndef process_module_in_graph(module: Dict[str, list], module_links: list, G: nx.DiGraph):\n    _module = os.path.basename(module)\n\n    module_edges = []\n\n    sub_edges = []\n    for entity in module_links:\n        module_edges.append((_module, entity))\n        for dep in module_links[entity]:\n            if "." in dep:\n                dep = dep.split(".")[1].replace(".", ".py")\n            sub_edges.append((entity, dep))\n        G.add_edges_from(sub_edges)\n    if not module_links:\n        G.add_node(_module)\n    G.add_edges_from(module_edges)\n    return module_edges, sub_edges
56,# location: codegraph/vizualyzer.py\ndef draw_graph(modules_entities: Dict) -> None:\n\n    G = nx.DiGraph()\n\n    module_edges_all = []\n\n    sub_edges_all = []\n\n    for module in modules_entities:\n        new_module_edges_all, new_edges_all = process_module_in_graph(\n            module, modules_entities[module], G\n        )\n\n        module_edges_all += new_module_edges_all\n        sub_edges_all += new_edges_all\n\n    pos = nx.spring_layout(G)\n    module_list = [os.path.basename(module) for module in modules_entities]\n    module_list_labels = {module_name: module_name for module_name in module_list}\n\n    entities_labels = {edge[1]: edge[1] for edge in module_edges_all}\n    nx.draw_networkx_nodes(\n        G,\n        pos,\n        nodelist=module_list,\n        node_color="#009c2c",\n        node_size=800,\n        node_shape="s",\n        alpha=0.8,\n    )\n    nx.draw(\n        G,\n        pos,\n        node_color="#009c2c",\n        arrows=False,\n        edge_color="#ffffff",\n        node_shape="o",\n        alpha=0.8,\n    )\n\n    nx.draw_networkx_labels(\n        G, pos, labels=module_list_labels, font_weight="bold", font_size=11\n    )\n    nx.draw_networkx_labels(\n        G,\n        pos,\n        labels=entities_labels,\n        font_weight="bold",\n        font_family="Arial",\n        font_size=10,\n    )\n\n    arrow_size = 15\n\n    nx.draw_networkx_edges(\n        G,\n        pos,\n        edgelist=module_edges_all,\n        edge_color="#009c2c",\n        width=2,\n        arrows=True,\n        arrowsize=arrow_size,\n        style="dashed",\n        node_size=50,\n    )\n    nx.draw_networkx_edges(\n        G,\n        pos,\n        edgelist=sub_edges_all,\n        edge_color="r",\n        width=2,\n        arrows=True,\n        arrowsize=arrow_size,\n        style="dashed",\n    )\n    for p in pos:\n        pos[p][1] += 0.07\n    plt.show()
57,# location: codegraph/wehr.py\ndef agaerg():\n    return cfa()
58,# location: tests/test_codegraph.py\ndef test_main():\n    module_path = (\n        pathlib.Path(__file__).parents[0] / "test_data" / "vizualyzer.py"\n    ).as_posix()\n    args = Namespace(paths=[module_path])\n    usage_graph = CodeGraph(args).usage_graph()\n    excepted = {\n        module_path: {\n            "draw_graph": ["process_module_in_graph"],\n            "process_module_in_graph": [],\n        }\n    }\n    assert sorted(usage_graph) == sorted(excepted)
59,# location: tests/test_data/vizualyzer.py\ndef process_module_in_graph(module: Dict[str, list], module_links: list, G: nx.DiGraph):\n    _module = os.path.basename(module)\n\n    module_edges = []\n\n    sub_edges = []\n    for entity in module_links:\n        module_edges.append((_module, entity))\n        for dep in module_links[entity]:\n            if "." in dep:\n                dep = dep.split(".")[1].replace(".", ".py")\n            sub_edges.append((entity, dep))\n        G.add_edges_from(sub_edges)\n    if not module_links:\n        G.add_node(_module)\n    G.add_edges_from(module_edges)\n    return module_edges, sub_edges
60,# location: tests/test_data/vizualyzer.py\ndef draw_graph(modules_entities: Dict) -> None:\n\n    G = nx.DiGraph()\n\n    module_edges_all = []\n\n    sub_edges_all = []\n\n    for module in modules_entities:\n        new_module_edges_all, new_edges_all = process_module_in_graph(\n            module, modules_entities[module], G\n        )\n\n        module_edges_all += new_module_edges_all\n        sub_edges_all += new_edges_all\n\n    pos = nx.spring_layout(G)\n    module_list = [os.path.basename(module) for module in modules_entities]\n    module_list_labels = {module_name: module_name for module_name in module_list}\n\n    entities_labels = {edge[1]: edge[1] for edge in module_edges_all}\n    nx.draw_networkx_nodes(\n        G,\n        pos,\n        nodelist=module_list,\n        node_color="#009c2c",\n        node_size=800,\n        node_shape="s",\n        alpha=0.8,\n    )\n    nx.draw(\n        G,\n        pos,\n        node_color="#009c2c",\n        arrows=False,\n        edge_color="#ffffff",\n        node_shape="o",\n        alpha=0.8,\n    )\n\n    nx.draw_networkx_labels(\n        G, pos, labels=module_list_labels, font_weight="bold", font_size=11\n    )\n    nx.draw_networkx_labels(\n        G,\n        pos,\n        labels=entities_labels,\n        font_weight="bold",\n        font_family="Arial",\n        font_size=10,\n    )\n    nx.draw_networkx_edges(\n        G,\n        pos,\n        edgelist=module_edges_all,\n        edge_color="#009c2c",\n        width=2,\n        arrows=False,\n        style="dashed",\n        node_size=50,\n    )\n    nx.draw_networkx_edges(\n        G,\n        pos,\n        edgelist=sub_edges_all,\n        edge_color="r",\n        width=2,\n        arrows=False,\n        style="dashed",\n    )\n    for p in pos:  # raise text positions\n        pos[p][1] += 0.07\n    plt.show()
61,# location: tests/test_utils.py\ndef test_get_python_paths_list_error():\n    with pytest.raises(ValueError) as e:\n        get_python_paths_list("../codegraph/core.py")\n        assert "does not exists" in str(e)
62,# location: tests/test_utils.py\ndef test_get_python_paths_list():\n    base_path = pathlib.Path(__file__).parents[1] / "codegraph"\n    expected = [\n        (base_path / x).as_posix()\n        for x in ["core.py", "parser.py", "utils.py", "vizualyzer.py", "main.py"]\n    ]\n    result = get_python_paths_list(base_path.as_posix())\n    assert sorted(result) == sorted(expected)
